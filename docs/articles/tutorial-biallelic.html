<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tutorial: bi-allelic data • MALECOT</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/yeti/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="Tutorial: bi-allelic data">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">MALECOT</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Vignettes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/installation.html">Installation</a>
    </li>
    <li>
      <a href="../articles/tutorial-biallelic.html">Tutorial 1: bi-allelic data</a>
    </li>
    <li>
      <a href="../articles/complex-priors.html">Tutorial 2: more realistic priors</a>
    </li>
    <li>
      <a href="../articles/tutorial-multiallelic.html">Tutorial 3: multi-allelic data</a>
    </li>
  </ul>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
<li>
  <a href="../articles/faq.html">FAQ</a>
</li>
<li>
  <a href="../articles/known-issues.html">Known issues</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/bobverity/malecot">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Tutorial: bi-allelic data</h1>
                        <h4 class="author">Bob Verity</h4>
            
            <h4 class="date">2018-09-17</h4>
      
      
      <div class="hidden name"><code>tutorial-biallelic.Rmd</code></div>

    </div>

    
    
<p>This vignette demonstrates a very basic MALECOT analysis for <em>bi-allelic</em> data, i.e. data for which there are two alleles at every locus. It covers:</p>
<ul>
<li>simulating/loading data into R</li>
<li>creating a project and binding data to the project</li>
<li>defining a simple parameter set</li>
<li>running the MCMC</li>
<li>checking MCMC behaviour</li>
<li>plotting results</li>
</ul>
<div id="simulate-some-data" class="section level3">
<h3 class="hasAnchor">
<a href="#simulate-some-data" class="anchor"></a>Simulate some data</h3>
<p>MALECOT comes with built-in functions for simulating data from different models. The models used in simulation are exactly the same as the models used in the inference step, allowing us to test the power of the program to arrive at the correct answer. We will simulate a data set of 100 samples, each genotyped at 24 loci and originating from 3 distinct subpopulations. We will assume that the mean complexity of infection (COI) in these subpopulation varies from 1.2 to 3:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mysim &lt;-<span class="st"> </span><span class="kw"><a href="../reference/sim_data.html">sim_data</a></span>(<span class="dt">n =</span> <span class="dv">100</span>, <span class="dt">data_format =</span> <span class="st">"biallelic"</span>, <span class="dt">L =</span> <span class="dv">24</span>, <span class="dt">K =</span> <span class="dv">3</span>, <span class="dt">COI_mean =</span> <span class="kw">c</span>(<span class="fl">1.2</span>,<span class="dv">2</span>,<span class="dv">3</span>))</code></pre></div>
<p>Running <code>names(mysim)</code> we can see that the simulated data contains several elements:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(mysim)</code></pre></div>
<pre><code>## [1] "data"       "n"          "L"          "true_group" "true_m"    
## [6] "true_p"     "call"</code></pre>
<p>The actual data that we are interested in is stored in the “data” element, but notice that we also have a record of the allele frequencies (“true_p”), the complexity of infection (“true_m”) and the grouping (“true_group”) that were used in generating these data. These additional records can be useful in ground-truthing our estimated values later on, but are not actually used by the program - all that is needed for MALECOT analysis is the “data” element.</p>
<p>Running <code>head(mysim$data)</code> we can see the general format required by MALECOT:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(mysim$data)</code></pre></div>
<pre><code>##   sample_ID pop locus1 locus2 locus3 locus4 locus5 locus6 locus7 locus8
## 1   samp001   1      0      1      0      0      0      1      0      1
## 2   samp002   1      1      1      1      1      0      1      0      1
## 3   samp003   1      0      1      0      1      0      1      1      0
## 4   samp004   1      0      0      1      0      0      1      1      0
## 5   samp005   1      0      0      0      0      0      1      1      0
## 6   samp006   1      0      1      0      0      0      1      0      1
##   locus9 locus10 locus11 locus12 locus13 locus14 locus15 locus16 locus17
## 1      0       1       1       1       0       0       0       1       1
## 2      0       1       1       1       1       0       1       1       0
## 3      0       1       1       1       1       0       1       0       0
## 4      0       1       1       1       0       0       1       0       0
## 5      0       1       1       1       1       0       1       1       1
## 6      0       1       1       1       0       0       0       1       1
##   locus18 locus19 locus20 locus21 locus22 locus23 locus24
## 1       0       1       0       1       0       1       1
## 2       0       1       0       1       1       0       1
## 3       1       0       0       1       0       1       1
## 4       0       0       0       1       0       1       1
## 5       0       1       0       0       0       1       1
## 6       0       0       0       1       0       0       1</code></pre>
<p>Note that this is the required format <strong>for bi-allelic data only</strong> - multi-allelic data is dealt with in <a href="https://bobverity.github.io/MALECOT/articles/tutorial-multiallelic.html">another vignette</a>.</p>
<p>Data must be in the form of a dataframe, with samples in rows and loci in columns. When using real data, functions such as <code>read.csv()</code> and <code>read.table()</code> can be used to import data in this format. There are several meta-data columns in the example above, including the sample ID and the population of origin. These meta-data columns are optional and can be turned on or off when loading the data into a project.</p>
<p>The actual genetic data must be one of the following values</p>
<ul>
<li>1 = homozygote for the reference (REF) allele</li>
<li>0 = homozygote for the alternative (ALT) allele</li>
<li>0.5 = heterozygote (both alleles seen)</li>
<li>-9 = missing data (this value can be specified, -9 is the default)</li>
</ul>
<p>MALECOT currently does not use within-sample allele frequency data - for example the raw read depth of REF vs. ALT alleles - and hence read depths should be converted to homozygote/heterozygote calls prior to analysis. It does, however, include error terms that allow for misclassification of homozygotes as heterozygotes and vice versa, which can account for some noise in the data.</p>
</div>
<div id="create-a-project-and-read-in-data" class="section level3">
<h3 class="hasAnchor">
<a href="#create-a-project-and-read-in-data" class="anchor"></a>Create a project and read in data</h3>
<p>MALCOT works with projects, which are essentially just simple lists containing all the inputs and outputs of a given analysis. We start by creating a project and loading in our data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myproj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/malecot_project.html">malecot_project</a></span>()
myproj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/bind_data_biallelic.html">bind_data_biallelic</a></span>(myproj, mysim$data, <span class="dt">ID_col =</span> <span class="dv">1</span>, <span class="dt">pop_col =</span> <span class="dv">2</span>)</code></pre></div>
<p>Notice the general format of the <code>bind_data()</code> function, which takes the same project as both input and output. This is the format that most MALECOT functions will take, as it allows a function to modify the project before overwriting the original version. In the input arguments we have specified which columns are meta-data, and all other columns are assumed to contain genetic data.</p>
<p>We can view the project to check that the data have been loaded in correctly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myproj</code></pre></div>
<pre><code>## DATA:
##    data format = biallelic
##    samples = 100
##    loci = 24
##    pops = 3
##    missing data = 0 of 2400 gene copies (0%)
## 
## PARAMETER SETS:
##    (none defined)</code></pre>
<p>If there have been mistakes in reading in the data, for example if meta-data columns have not been specified and so have been interpreted as genetic data (a common mistake) then this should be visible at this stage.</p>
</div>
<div id="define-parameters-and-run-basic-mcmc" class="section level3">
<h3 class="hasAnchor">
<a href="#define-parameters-and-run-basic-mcmc" class="anchor"></a>Define parameters and run basic MCMC</h3>
<p>We can define different models by using different parameter sets. Our first parameter set will represent a simple model in which any COI between 1 and <code>COI_max</code> is equally likely <em>a priori</em>. We also assume zero error in genotype calls:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myproj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/new_set.html">new_set</a></span>(myproj, <span class="dt">name =</span> <span class="st">"uniform model"</span>, <span class="dt">COI_model =</span> <span class="st">"uniform"</span>, <span class="dt">COI_max =</span> <span class="dv">20</span>,
                  <span class="dt">estimate_error =</span> <span class="ot">FALSE</span>, <span class="dt">e1 =</span> <span class="fl">0.0</span>, <span class="dt">e2 =</span> <span class="fl">0.0</span>)</code></pre></div>
<p>Viewing the project we can now see additional properties, including the current active set and the parameters of this set.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myproj</code></pre></div>
<pre><code>## DATA:
##    data format = biallelic
##    samples = 100
##    loci = 24
##    pops = 3
##    missing data = 0 of 2400 gene copies (0%)
## 
## PARAMETER SETS:
##  * SET1: uniform model
## 
## ACTIVE SET: SET1
##    lambda = 1
##    COI model = uniform
##    COI max = 20
##    estimate error = FALSE
##    e1 = 0
##    e2 = 0</code></pre>
<p>Now we are ready to run a basic MCMC. We will start by exploring values of <em>K</em> from 1 to 5, using 10,000 burn-in iterations and 1000 sampling iterations. By default the MCMC has <code>auto_converge</code> turned on, meaning it will test for convergence every <code>convergence_test</code> iterations and will exit if convergence is reached. Hence, it is generally a good idea to set <code>burnin</code> to be higher than expected, as the MCMC will adjust this number down if needed. The number of sampling iterations can also be tuned. Our aim when choosing the number of sampling iterations should be to obtain enough samples that our posterior estimates are accurate to an acceptable tolerance level, but not so many that we waste time running the MCMC for long periods past this point. We will look into this parameter again once the MCMC has completed. The most unfamiliar parameter for most users will be the number of “rungs”. MALECOT runs multiple MCMC chains simultaneously, each at a different rung on a “temperature ladder”. The cold chain is our ordinary MCMC chain, and the hot chains serve two purposes: 1) they improve MCMC mixing, 2) they are central to the GTI method of estimating the evidence for different models. Finally, for the sake of this document we will run with <code>pb_markdown = TRUE</code> to avoid printing large amounts of output, but you should omit this argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myproj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/run_mcmc.html">run_mcmc</a></span>(myproj, <span class="dt">K =</span> <span class="dv">1</span>:<span class="dv">5</span>, <span class="dt">burnin =</span> <span class="fl">1e4</span>, <span class="dt">converge_test =</span> <span class="fl">1e2</span>, <span class="dt">samples =</span> <span class="fl">1e3</span>,
                   <span class="dt">rungs =</span> <span class="dv">10</span>, <span class="dt">pb_markdown =</span>  <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Running MCMC for K = 1
## Burn-in phase
## 
  |                                                                       
  |=================================================================| 100%
##    converged within 200 iterations
## Sampling phase
## 
  |                                                                       
  |=================================================================| 100%
##    completed in 1.05436 seconds
## 
## Running MCMC for K = 2
## Burn-in phase
## 
  |                                                                       
  |=================================================================| 100%
##    converged within 200 iterations
## Sampling phase
## 
  |                                                                       
  |=================================================================| 100%
##    completed in 1.78358 seconds
## 
## Running MCMC for K = 3
## Burn-in phase
## 
  |                                                                       
  |=================================================================| 100%
##    converged within 200 iterations
## Sampling phase
## 
  |                                                                       
  |=================================================================| 100%
##    completed in 2.27436 seconds
## 
## Running MCMC for K = 4
## Burn-in phase
## 
  |                                                                       
  |=================================================================| 100%
##    converged within 200 iterations
## Sampling phase
## 
  |                                                                       
  |=================================================================| 100%
##    completed in 2.84695 seconds
## 
## Running MCMC for K = 5
## Burn-in phase
## 
  |                                                                       
  |=================================================================| 100%
##    converged within 200 iterations
## Sampling phase
## 
  |                                                                       
  |=================================================================| 100%
##    completed in 3.24119 seconds
## 
## Processing results</code></pre>
<pre><code>## Total run-time: 12.84 seconds</code></pre>
<p>If any values of K failed to converge then we can use the same <code><a href="../reference/run_mcmc.html">run_mcmc()</a></code> function to re-run the MCMC for just a single value of K and with different parameters (for example a longer burn-in). This will overwrite the existing output for the specified value of K, but will leave all other values untouched:</p>
</div>
<div id="comparing-values-of-k" class="section level3">
<h3 class="hasAnchor">
<a href="#comparing-values-of-k" class="anchor"></a>Comparing values of K</h3>
<p>The GTI method estimates the evidence for a given model by combining information across multiple temperature rungs. These rungs provide a series of point estimates that together make a “path”, and the final evidence estimate is computed from the area between this path and the zero-line. We can visualise this path using the <code><a href="../reference/plot_GTI_path.html">plot_GTI_path()</a></code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot_GTI_path.html">plot_GTI_path</a></span>(myproj, <span class="dt">K =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-10-1.png" width="700"></p>
<p>Note that all plots produced by MALECOT are produced as <a href="https://ggplot2.tidyverse.org/">ggplot</a> objects, meaning they can be stored and modified later - for example by adding titles and legends.</p>
<p>In order for our evidence estimate to be unbiased it is important that the GTI path is relatively smooth. We can modify the smoothness of the path in two ways: 1) by increasing the number of <code>rungs</code> used in the MCMC, 2) by changing the value of <code>GTI_pow</code> which controls the curvature of the path (higher values lead to more steep curvature). Ideally we want a straight path, i.e. we want as little curvature as possible. In the example above we have a good number of rungs and the path is relatively straight, so there is no need to re-run the MCMC. <strong>This check should be performed on every value of K</strong>.</p>
<p>Once we are happy with our GTI paths we can look at our evidence estimates, first of all in log space:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot_logevidence_K.html">plot_logevidence_K</a></span>(myproj)</code></pre></div>
<p><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-11-1.png" width="700"></p>
<p>We can see a clear signal for K=3 or higher, and the 95% credible intervals are nice and tight. If we needed tighter credible intervals at this stage then we could re-run the MCMC (for the problem values of K only) with a larger number of <code>samples</code>.</p>
<p>We can also plot the full posterior distribution of K, which is obtained by transforming these values out of log space and normalising to sum to one:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot_posterior_K.html">plot_posterior_K</a></span>(myproj)</code></pre></div>
<p><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-12-1.png" width="700"></p>
<p>This second plot is usually more straightforward to interpret, as it is in linear space and so can be understood in terms of ordinary probability. In this example we can see strong evidence for K=3, with a posterior probability of &gt;0.99. Again, if we had seen wide credible intervals at this stage then it would have been worth repeating the MCMC with a larger number of <code>samples</code>, but in this case the result is clear and so there is no need.</p>
</div>
<div id="structure-and-coi-plots" class="section level3">
<h3 class="hasAnchor">
<a href="#structure-and-coi-plots" class="anchor"></a>Structure and COI plots</h3>
<p>The main result of interest from this sort of analysis is usually the posterior allocation or “structure” plot. This plot contains one bar for each sample, with the proportion of each colour giving the posterior probability of belonging to each of the <em>K</em> subpopulations. We can use the <code><a href="../reference/plot_qmatrix.html">plot_qmatrix()</a></code> function to produce posterior allocation plots for different values of <em>K</em>. The <code>divide_ind_on</code> argument adds white lines between individual samples, and can be turned off if these lines start getting in the way.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot_qmatrix.html">plot_qmatrix</a></span>(myproj, <span class="dt">K =</span> <span class="dv">2</span>:<span class="dv">5</span>, <span class="dt">divide_ind_on =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-13-1.png" width="768"></p>
<p>We can see that for <em>K</em>=3 (the most highly supported value of <em>K</em>) there is a clear split into three distinct subpopulations. The advantage of simulated data is that we can verify that this is the correct grouping by looking at <code>mysim$true_group</code>, although obviously this is not possible for real data.</p>
<p>When reporting and publishing results it is a good idea to produce posterior allocation and COI plots for a range of values of <em>K</em> so that the reader has the option of visualising structure at multiple levels, and ideally this should also be backed up by a plot of the model evidence to give some idea of the model fit at each level. At this stage it is worth stressing the point made by many previous authors - <strong>the model used by MALECOT and similar programs is just a cartoon of reality, and there is no strict K in the real world</strong>. Instead, each K captures a different level of population structure, and while the evidence can help guide us towards values of <em>K</em> that fit the data well, it is just a guide and should be taken alongside other biological considerations.</p>
<p>Next we will plot the posterior COI of all samples. The example below uses the <code>ggplot2</code> package to add the true (i.e. simulated) COIs to the plot in the form of red crosses.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># plot posterior COIs</span>
posterior_m &lt;-<span class="st"> </span><span class="kw"><a href="../reference/plot_m_quantiles.html">plot_m_quantiles</a></span>(myproj, <span class="dt">K =</span> <span class="dv">3</span>)

<span class="co"># overlay true values</span>
<span class="kw">library</span>(ggplot2)
posterior_m &lt;-<span class="st"> </span>posterior_m +<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/geom_point">geom_point</a></span>(<span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/aes">aes</a></span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">100</span>, <span class="dt">y =</span> mysim$true_m), <span class="dt">col =</span> <span class="st">"red"</span>, <span class="dt">shape =</span> <span class="dv">4</span>)
posterior_m</code></pre></div>
<p><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-14-1.png" width="768"></p>
<p>Comparing the posterior 95% credible intervals (black) with the true COIs (red), we can see that the model has done well in some cases and poorly in others. COI estimates are most precise when the COI is very low (1 or 2), but are highly imprecise when COI is large. The model has also picked up the general trend in the simulated data, with the mean COI being lowest in the first subpopulation and highest in the last, but unfortunately it has systematically overestimated the COI as a whole. This is down to our choice of uniform prior on COI, which gives equal weight to any COI from 1 to 20. In fact, the simulated data are drawn from a more realistic Poisson distribution, in which COIs tend to be clustered around a central value, and so the uniform prior gives too much flexibility in this example. We will address this issue, along with some other weaknesses of the model, in the <a href="https://bobverity.github.io/MALECOT/articles/complex-priors.html">next tutorial</a>.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Bob Verity.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
