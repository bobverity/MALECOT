<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bi-allelic data • MALECOT</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="Bi-allelic data">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">MALECOT</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Vignettes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/installation.html">Installation</a>
    </li>
    <li>
      <a href="../articles/tutorial-biallelic.html">Tutorial 1: bi-allelic data</a>
    </li>
    <li>
      <a href="../articles/complex-priors.html">Tutorial 2: more realistic models</a>
    </li>
    <li>
      <a href="../articles/multiallelic-data.html">Tutorial 3: multi-allelic data</a>
    </li>
    <li>
      <a href="../articles/comparing-models.html">Tutorial 4: comparing models (estimating K)</a>
    </li>
    <li>
      <a href="../articles/running-in-parallel.html">Tutorial 5: running in parallel</a>
    </li>
    <li class="divider">
    <li class="dropdown-header">Advanced topics</li>
    <li>
      <a href="../articles/ensuring-good-mixing.html">Ensuring good mixing</a>
    </li>
    <li>
      <a href="../articles/power-analysis-within-model.html">Power analysis - within model</a>
    </li>
    <li>
      <a href="../articles/power-analysis-between-models.html">Power analysis - between models</a>
    </li>
    <li>
      <a href="../articles/gti-mathematical-details.html">GTI mathematical details</a>
    </li>
  </ul>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/bobverity/malecot">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Bi-allelic data</h1>
                        <h4 class="author">Bob Verity</h4>
            
            <h4 class="date">2018-09-26</h4>
      
      
      <div class="hidden name"><code>tutorial-biallelic.Rmd</code></div>

    </div>

    
    
<p>This vignette demonstrates a very basic MALECOT analysis for bi-allelic data, i.e. data for which there are two alleles at every locus. It covers:</p>
<ol style="list-style-type: decimal">
<li>Simulating/loading data into R</li>
<li>Creating a project and binding data to the project</li>
<li>Defining a simple parameter set</li>
<li>Running the MCMC</li>
<li>Checking MCMC behaviour</li>
<li>Plotting results</li>
</ol>
<div id="simulate-some-data" class="section level2">
<h2 class="hasAnchor">
<a href="#simulate-some-data" class="anchor"></a>Simulate some data</h2>
<p>MALECOT comes with built-in functions for simulating data from different models. The models used in simulation are exactly the same as the models used in the inference step, allowing us to test the power of the program to arrive at the correct answer. We will simulate a data set of 100 samples, each genotyped at 24 loci and originating from 3 distinct subpopulations or <a href="https://en.wikipedia.org/wiki/Deme_(biology)">demes</a>. We will assume that the mean complexity of infection (COI) in these three subpopulation varies from 1.2 to 3:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mysim &lt;-<span class="st"> </span><span class="kw"><a href="../reference/sim_data.html">sim_data</a></span>(<span class="dt">data_format =</span> <span class="st">"biallelic"</span>, <span class="dt">n =</span> <span class="dv">100</span>, <span class="dt">L =</span> <span class="dv">24</span>, <span class="dt">K =</span> <span class="dv">3</span>, <span class="dt">COI_mean =</span> <span class="kw">c</span>(<span class="fl">1.2</span>,<span class="dv">2</span>,<span class="dv">3</span>))</code></pre></div>
<p>Running <code>names(mysim)</code> we can see that the simulated data contains several elements:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(mysim)</code></pre></div>
<pre><code>## [1] "data"       "n"          "L"          "true_group" "true_m"    
## [6] "true_p"     "call"</code></pre>
<p>The actual data that we are interested in is stored in the “data” element, but notice that we also have a record of the allele frequencies (“true_p”), the complexity of infection (“true_m”) and the grouping (“true_group”) that were used in generating these data. These additional records can be useful in ground-truthing our estimated values later on, but are not actually used by the program - all that is needed for MALECOT analysis is the “data” element.</p>
<p>Running <code>head(mysim$data)</code> we can see the general format required by MALECOT:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(mysim$data)</code></pre></div>
<pre><code>##   sample_ID pop locus1 locus2 locus3 locus4 locus5 locus6 locus7 locus8
## 1   samp001   1      0      0      0      0      1      1      0      0
## 2   samp002   1      0      1      0      1      0      1      0      1
## 3   samp003   1      0      1      1      1      0      1      0      1
## 4   samp004   1      0      1      0      0      1      1      0      0
## 5   samp005   1      0      1      0      0      1      1      0      0
## 6   samp006   1      0      1      1      0      0      1      1      1
##   locus9 locus10 locus11 locus12 locus13 locus14 locus15 locus16 locus17
## 1      0       0       1       0       0       0       1       0       0
## 2      0       1       1       0       0       1       1       1       1
## 3      0       0       0       0       1       0       1       0       1
## 4      1       0       1       0       0       0       1       1       1
## 5      1       0       0       1       0       0       0       1       1
## 6      0       0       1       1       0       0       1       0       1
##   locus18 locus19 locus20 locus21 locus22 locus23 locus24
## 1       1       0       1       0       0       1       0
## 2       0       1       1       1       1       1       0
## 3       1       0       1       0       1       1       1
## 4       0       1       1       1       0       1       0
## 5       1       1       1       1       1       0       1
## 6       1       0       0       0       0       1       0</code></pre>
<p>Note that this is the required format for bi-allelic data only - multi-allelic data is dealt with in <a href="https://bobverity.github.io/MALECOT/articles/tutorial-multiallelic.html">another vignette</a>.</p>
<p>Data must be in the form of a dataframe, with samples in rows and loci in columns. When using real data, functions such as <code>read.csv()</code> and <code>read.table()</code> can be used to import data in dataframe format. There are also several meta-data columns in the example above, including the sample ID and the population of origin. These meta-data columns are optional and can be turned on or off when loading the data into a project.</p>
<p>The actual genetic data must be one of the following values</p>
<ul>
<li>1 = homozygote for the reference allele (REF)</li>
<li>0 = homozygote for the alternative allele (ALT)</li>
<li>0.5 = heterozygote (both REF and ALT alleles observed)</li>
<li>-9 = missing data. This value can be specified, but -9 is the default</li>
</ul>
<p>MALECOT currently does not use within-sample allele frequency data, for example the raw read depth of REF vs. ALT alleles, and hence read depths should be converted to homozygote/heterozygote calls prior to analysis.</p>
</div>
<div id="create-a-project-and-read-in-data" class="section level2">
<h2 class="hasAnchor">
<a href="#create-a-project-and-read-in-data" class="anchor"></a>Create a project and read in data</h2>
<p>MALCOT works with projects, which are essentially just simple lists containing all the inputs and outputs of a given analysis. We start by creating a project and loading in our data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myproj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/malecot_project.html">malecot_project</a></span>()
myproj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/bind_data_biallelic.html">bind_data_biallelic</a></span>(myproj, mysim$data, <span class="dt">ID_col =</span> <span class="dv">1</span>, <span class="dt">pop_col =</span> <span class="dv">2</span>)</code></pre></div>
<p>Notice the general format of the <code>bind_data()</code> function, which takes the same project as both input and output. This is the format that most MALECOT functions will take, as it allows a function to modify the project before overwriting the original version. In the input arguments we have specified which columns are meta-data, and all other columns are assumed to contain genetic data unless otherwise specified.</p>
<p>We can view the project to check that the data have been loaded in correctly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myproj</code></pre></div>
<pre><code>## DATA:
##    data format = biallelic
##    samples = 100
##    loci = 24
##    pops = 3
##    missing data = 0 of 2400 gene copies (0%)
## 
## PARAMETER SETS:
##    (none defined)</code></pre>
<p>If there have been mistakes in reading in the data, for example if meta-data columns have not been specified and so have been interpreted as genetic data (a common mistake), then this should be visible at this stage.</p>
</div>
<div id="define-parameters-and-run-basic-mcmc" class="section level2">
<h2 class="hasAnchor">
<a href="#define-parameters-and-run-basic-mcmc" class="anchor"></a>Define parameters and run basic MCMC</h2>
<p>We can define different models by using different parameter sets. Our first parameter set will represent a simple model in which any COI between 1 and <code>COI_max</code> is equally likely <em>a priori</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myproj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/new_set.html">new_set</a></span>(myproj, <span class="dt">name =</span> <span class="st">"uniform model"</span>, <span class="dt">COI_model =</span> <span class="st">"uniform"</span>, <span class="dt">COI_max =</span> <span class="dv">20</span>)</code></pre></div>
<p>Viewing the project we can now see additional properties, including the current active set and the parameters of this set:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myproj</code></pre></div>
<pre><code>## DATA:
##    data format = biallelic
##    samples = 100
##    loci = 24
##    pops = 3
##    missing data = 0 of 2400 gene copies (0%)
## 
## PARAMETER SETS:
##  * SET1: uniform model
## 
## ACTIVE SET: SET1
##    lambda = 1
##    COI model = uniform
##    COI max = 20
##    estimate error = FALSE
##    e1 = 0
##    e2 = 0</code></pre>
<p>All analyses and plotting functions default to using the active set. We can change the active set using the function <code><a href="../reference/active_set.html">active_set()</a></code>, or we can delete parameter sets with <code><a href="../reference/delete_set.html">delete_set()</a></code>.</p>
<p>Now we are ready to run our first MCMC. We will start by exploring values of <span class="math inline">\(K\)</span> from 1 to 5, using 10,000 burn-in iterations and 10,000 sampling iterations. The burn-in phase is required for the MCMC to “forget” its initial conditions and converge on the correct answer. By default the MCMC has <code>auto_converge</code> turned on, meaning it will test for convergence every <code>convergence_test</code> iterations and will exit if convergence is reached. Hence, it is generally a good idea to set <code>burnin</code> to a high value, as the MCMC will adjust this number down if needed. The number of sampling iterations can also be tuned. Our aim when choosing the number of sampling iterations should be to obtain enough samples that our posterior estimates are accurate to an acceptable tolerance level, but not so many that we waste time running the MCMC for long periods past this point. We will look into this parameter again once the MCMC has completed. Finally, for the sake of this document we will run with <code>pb_markdown = TRUE</code> to avoid printing large amounts of output, but you should omit this argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myproj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/run_mcmc.html">run_mcmc</a></span>(myproj, <span class="dt">K =</span> <span class="dv">1</span>:<span class="dv">5</span>, <span class="dt">burnin =</span> <span class="fl">1e4</span>, <span class="dt">converge_test =</span> <span class="fl">1e2</span>,
                   <span class="dt">samples =</span> <span class="fl">1e4</span>, <span class="dt">pb_markdown =</span>  <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Running MCMC for K = 1
## Burn-in phase
## 
  |                                                                       
  |=================================================================| 100%
##    converged within 200 iterations
## 2.6514 1.38193 2.54784 1.40139 1.9979 1.2052 2.02467 1.26653 2.56665 2.92088 1.77326 1.82615 1.47809 1.03564 1.04099 1 1.42841 2.13056 1.23839 1.78557 1.93313 1.86732 1.57065 1.83689 1.88756 1.66731 1.54269 1 1.41182 1.87598 1.67062 1.48505 1.5622 2.05758 1.56029 1.61179 1.86218 2.74741 3.10724 2.81392 1.29014 1.81595 1.88513 2.09717 1.74891 2.19897 3.4367 1.67137 2.14947 1.47258 3.38252 1.96666 1.70488 1.73072 1.20425 1.46428 1.49999 1.80517 1.6597 1.5226 2.07907 1.30083 1.61852 1.61997 1 1.3839 1.28874 1 4.88053 1.78524 4.0202 2.2743 3.36493 3.25889 2.86888 2.8397 3.00681 1.97037 2.57237 2.76697 3.83601 1.75896 4.47399 1.63477 4.06614 2.51097 2.05829 1.5888 3.68778 1 3.63713 4.28346 2.60686 3.03652 2.77141 2.90879 2.41829 1.78356 1.19509 2.88084 
## Sampling phase
## 
  |                                                                       
  |=================================================================| 100%
##    completed in 0.792072 seconds
## 
## Running MCMC for K = 2
## Burn-in phase
## 
  |                                                                       
  |=================================================================| 100%
##    converged within 200 iterations
## 1.63885 2.0965 1 1.62532 1.75021 1.14958 2.85654 1 1.23522 2.41084 2.55578 2.25913 1.28739 1.39205 2.76406 1.48251 1.69422 1.54458 1.61678 1.43789 2.15312 1.87439 1.10835 1.73568 1.84784 2.4234 1 1.1054 2.43561 2.11942 2.35567 2.14158 1.25387 1.5261 1.04173 3.80741 1.02367 3.87561 4.2357 1.73748 3.12421 2.12225 2.32674 1.95022 4.93332 4.30693 5.38651 2.68953 2.56916 3.89668 4.54361 2.74735 2.60805 2.29898 1.61779 1.28642 2.26296 1.58167 1.76275 1.70088 3.11224 3.75668 3.87847 4.08322 1.00711 1.25944 1.5942 1.14046 6.93873 1.86861 2.62691 3.46113 3.54483 3.49963 3.9077 4.59158 4.33296 2.69532 3.84686 1.85016 4.94796 1.27649 5.08453 1.97315 3.92291 1 2.11929 1.38794 3.33212 2.83609 5.52657 3.27219 3.6485 2.11126 4.21632 5.81968 3.43817 1.50071 1.28841 5.03058 
## Sampling phase
## 
  |                                                                       
  |=================================================================| 100%
##    completed in 1.50861 seconds
## 
## Running MCMC for K = 3
## Burn-in phase
## 
  |                                                                       
  |=================================================================| 100%
##    converged within 100 iterations
## 2.93563 2.1223 2.23838 3.65797 2.46373 2.30656 2.60162 1.73875 3.00686 2.76526 3.29502 2.6447 2.87839 2.60052 2.52477 2.50756 2.11229 2.47389 2.22076 2.49331 2.69498 2.21559 2.26446 2.12859 2.3026 2.36178 2.7528 3.45181 3.08422 2.67532 1.75248 1.94372 2.76194 2.19772 2.65316 3.10764 3.2745 4.60314 4.05922 2.83471 4.78176 2.21303 2.53246 3.27637 3.72181 4.92281 4.78001 2.07217 3.69842 4.49604 5.70354 3.86409 2.19539 2.62271 2.18224 2.98627 2.84934 1.72052 2.68467 2.77498 4.38834 3.77734 4.46605 3.76779 2.70624 2.76693 3.42737 2.56506 6.37714 3.34372 4.72087 4.07256 3.56904 3.71272 5.24779 5.52176 5.09514 4.68811 2.38246 2.05987 6.94328 3.61115 4.89815 2.65471 5.96994 1.11409 2.32185 3.07511 5.20828 2.77563 6.7883 4.27783 3.96492 3.93694 4.71727 4.86706 5.48924 3.01348 2.36675 5.17181 
## Sampling phase
## 
  |                                                                       
  |=================================================================| 100%
##    completed in 1.99085 seconds
## 
## Running MCMC for K = 4
## Burn-in phase
## 
  |                                                                       
  |=================================================================| 100%
##    converged within 100 iterations
## 2.39187 2.32817 3.22079 2.24905 1.84195 3.52696 3.76643 2.00684 1.9284 3.37809 1.8419 3.34029 2.46337 2.55208 2.83263 1.77018 1.97974 2.15058 2.97035 2.6875 2.25648 1.50645 3.54931 3.7082 1.98689 2.83806 3.64364 2.47908 3.16912 2.06821 1.43719 2.6009 2.92521 2.44928 2.32095 3.57853 2.93966 4.69395 2.31252 3.34583 4.17081 1.94371 2.29874 2.68666 3.7898 4.94791 4.31502 2.8026 4.03177 4.04275 4.6457 3.60883 2.58638 2.49694 2.20254 2.44354 2.12543 1.88156 2.37099 2.61694 2.5419 3.55962 4.21195 4.65222 3.03663 2.36174 1.92858 3.25364 5.85078 4.26568 5.44226 4.27269 4.68122 3.87457 5.27374 5.66791 5.11209 2.88844 3.46411 3.00506 6.31589 3.89259 4.92791 2.52565 6.71448 2.48418 2.50085 3.14685 4.46397 4.03691 7.40693 4.41954 4.15359 3.21111 6.01583 6.90229 6.17888 3.43556 3.12441 5.53273 
## Sampling phase
## 
  |                                                                       
  |=================================================================| 100%
##    completed in 2.52623 seconds
## 
## Running MCMC for K = 5
## Burn-in phase
## 
  |                                                                       
  |=================================================================| 100%
##    converged within 100 iterations
## 2.60314 2.35449 2.59816 2.97709 2.66496 2.03631 3.80396 2.60573 2.46177 3.6225 2.43149 3.0246 3.01894 2.66421 2.85771 2.60711 2.65834 2.3103 2.81826 3.08362 2.54633 2.06916 2.90089 2.92877 3.41645 3.05931 2.27693 2.24058 2.20504 2.16928 3.31442 2.86024 2.27786 1.51118 1.63541 3.97381 2.53778 3.07887 3.53094 2.64716 4.5032 2.46733 3.27685 2.6361 5.08547 4.15871 3.75955 2.74698 3.60984 4.69959 5.56571 3.69215 3.38636 2.96319 2.24635 2.66075 3.12756 3.27003 2.75029 2.10831 2.64105 3.17956 4.71915 3.71929 2.8912 2.99745 2.84765 2.86404 6.58206 4.75599 6.18392 3.00213 4.47586 5.02707 4.47356 4.97137 6.35144 4.02134 3.95178 3.26366 7.37471 4.10533 5.54055 1.61615 6.1745 2.71041 2.0558 2.69975 5.38648 3.94568 7.94652 3.99204 4.38019 3.91787 5.47878 4.37855 5.05949 3.14719 2.69675 6.32785 
## Sampling phase
## 
  |                                                                       
  |=================================================================| 100%
##    completed in 2.97804 seconds
## 
## Processing results</code></pre>
<pre><code>## Total run-time: 12.16 seconds</code></pre>
<p>If any values of <span class="math inline">\(K\)</span> failed to converge then we could use the same <code><a href="../reference/run_mcmc.html">run_mcmc()</a></code> function to re-run the MCMC for just a single value of <span class="math inline">\(K\)</span> and with different parameters (for example a longer burn-in). This will overwrite the existing output for the specified value of <span class="math inline">\(K\)</span>, but will leave all other values untouched:</p>
</div>
<div id="checking-mcmc-behaviour" class="section level2">
<h2 class="hasAnchor">
<a href="#checking-mcmc-behaviour" class="anchor"></a>Checking MCMC behaviour</h2>
<p>Before diving into results, it is important to check that our MCMC has behaved as expected. There are many ways of checking MCMC performace, and here we will focus on only the most simple checks.</p>
<p>We can explore the estimated log-likelihood values through a series of diagnostic plots:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot_loglike_dignostic.html">plot_loglike_dignostic</a></span>(myproj, <span class="dt">K =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-12-1.png" width="768"></p>
<p>The top panel shows a “trace plot”" of the log-likelihood, in other words it shows the value of the log-likelihood at each sampling iteration of the MCMC, and the bottom right panel shows a histogram of these same values. We can see that the log-likelihood has fluctuated around a single stable value, and has bounced around freely enough to cover the same range of values many times over. This is exactly what we want to see - ideally a trace plot should look like a fuzzy black caterpillar! This indicates that the MCMC has <em>probably</em> explored the space well, although we can never rule out that there might be another “level” of log-likelihood that the MCMC has not found yet. This is one of the many paradoxes of MCMC - we can never be 100% sure that an MCMC has completely explored the space, we can only diagnose if it definitly <em>hasn’t</em> explored the space well. In other words, when looking at these plots we are looking for tell-tale signs of <em>bad</em> MCMC behaviour, such as jumping sporadically between levels or moving very slowly through a range of values.</p>
<p>The bottom left panel shows the level of autocorrelation in the trace plot for different degrees of separation between points (lags). When autocorrelation approaches zero it means that values are approximately independent - this occurs at around 20 lags here, meaning every 20th draw is approximately independent. The number of <em>independent</em> samples is therefore much smaller than the raw number of samples. We can use the <code><a href="../reference/get_ESS.html">get_ESS()</a></code> function to get at exactly how many effectively independent samples we have:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/get_ESS.html">get_ESS</a></span>(myproj, <span class="dt">K =</span> <span class="dv">3</span>)</code></pre></div>
<pre><code>##    rung1 
## 1342.089</code></pre>
<p>It is worth keeping this value in mind when looking at trace plots so we are not fooled by large numbers of iterations. If our ESS is very small (tens to hundreds) then we are extremely unlikely to have explored the full model space, even if the raw number of sampling iterations is in the millions.</p>
<p>These checks should be carried out on each value of <span class="math inline">\(K\)</span>, and if any results show signs of poor MCMC behaviour then they should be repeated with larger sample sizes, or using other <a href="https://bobverity.github.io/MALECOT/articles/ensuring-good-mixing.html">more sophisticated techniques</a> to improve mixing.</p>
</div>
<div id="plot-results" class="section level2">
<h2 class="hasAnchor">
<a href="#plot-results" class="anchor"></a>Plot results</h2>
<div id="structure-plots" class="section level3">
<h3 class="hasAnchor">
<a href="#structure-plots" class="anchor"></a>Structure plots</h3>
<p>Usually the main result of interest from this sort of analysis is the posterior allocation or “structure” plot. This plot contains one bar for each sample, with the proportion of each colour giving the posterior probability of belonging to each of the <span class="math inline">\(K\)</span> subpopulations. We can use the <code><a href="../reference/plot_structure.html">plot_structure()</a></code> function to produce posterior allocation plots for different values of <span class="math inline">\(K\)</span>. The <code>divide_ind_on</code> argument adds white lines between individual samples, and can be turned off if these lines start getting in the way.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot_structure.html">plot_structure</a></span>(myproj, <span class="dt">K =</span> <span class="dv">2</span>:<span class="dv">5</span>, <span class="dt">divide_ind_on =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-14-1.png" width="768"></p>
<p>The advantage of simulated data is that we know the true value of <span class="math inline">\(K\)</span> used when generating the data (<span class="math inline">\(K = 3\)</span> in this case) as well as which samples belong to which groups, meaning we can verify whether the model has arrived at the correct answer. In this example almost all samples are allocated correctly for <span class="math inline">\(K = 3\)</span>. The issue of deciding between different values of <span class="math inline">\(K\)</span> is a big one, and will be dealt with in <a href="https://bobverity.github.io/MALECOT/articles/comparing-models.html">a later tutorial</a>.</p>
</div>
<div id="posterior-coi-plots" class="section level3">
<h3 class="hasAnchor">
<a href="#posterior-coi-plots" class="anchor"></a>Posterior COI plots</h3>
<p>Next we can plot the posterior COI of our samples. All plots produced by MALECOT are produced as <a href="https://ggplot2.tidyverse.org/">ggplot</a> objects, meaning they can be stored and modified later. For example, here we overlay the true (i.e. simulated) COIs on top of the posterior estimates:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># load ggplot2 package (which must be already installed)</span>
<span class="kw">library</span>(ggplot2)

<span class="co"># store plot of posterior COIs as object</span>
posterior_COI &lt;-<span class="st"> </span><span class="kw"><a href="../reference/plot_COI.html">plot_COI</a></span>(myproj, <span class="dt">K =</span> <span class="dv">3</span>)

<span class="co"># overlay true COI values</span>
posterior_COI &lt;-<span class="st"> </span>posterior_COI +<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/geom_point">geom_point</a></span>(<span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/aes">aes</a></span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">100</span>, <span class="dt">y =</span> mysim$true_m), <span class="dt">col =</span> <span class="st">"red"</span>, <span class="dt">shape =</span> <span class="dv">4</span>)

posterior_COI</code></pre></div>
<p><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-15-1.png" width="768"></p>
<p>Comparing the posterior 95% credible intervals (black) with the true COIs (red), we can see that the model has mostly done a good job of estimating COIs. Estimates are fairly precise when the COI is very low (1 or 2), but they become very imprecise when COI is large. The model has also picked up the general trend in the simulated data, being lowest in the first subpopulation and highest in the last, but unfortunately it has systematically overestimated the COI across the board - this can be seen by the fact that most red crosses are in the lower half of the credible intervals. This is down to our choice of uniform prior on COI, which gives equal weight to any COI from 1 to 20. In reality (and in this simulated data) most COIs will tend to be clustered around small values, and so the uniform prior gives too much flexibility. We will address this issue, along with some other weaknesses of the model, in the <a href="https://bobverity.github.io/MALECOT/articles/complex-priors.html">next tutorial</a>.</p>
</div>
<div id="posterior-allele-frequency-plots" class="section level3">
<h3 class="hasAnchor">
<a href="#posterior-allele-frequency-plots" class="anchor"></a>Posterior allele frequency plots</h3>
<p>The third parameter of interest is the posterior allele frequency at each locus and in each subpopulation. Again, we have a record of the true values so we can check that the model output matches these values.</p>
<p>Before doing so, however, we need to revisit structure plots. One thing to note when looking at structure plots is that the group labelling is arbitrary, and labels can be swapped around without undermining results. For example, we could swap around what we call group1 and group2 in the structure plots above and the overall estimated structure would be the same. In fact, the group labels used in MALECOT are simply chosen to minimise the visual differences between plots - for example, in the structure plots above the colours are chosen to align most closely between different values of <span class="math inline">\(K\)</span>.</p>
<p>However, when comparing true allele frequencies against MCMC output we need to make sure our labels match up. We can do this using the <code><a href="../reference/get_group_order.html">get_group_order()</a></code> function, which takes a project and value of <span class="math inline">\(K\)</span> as input, along with a “target group”. The target group will be matched against the MCMC output and re-ordered as needed to get the best possible matching. For example, using <code>mysim$true_group</code> as the target group we obtain:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">group_order_k3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/get_group_order.html">get_group_order</a></span>(myproj, <span class="dt">K =</span> <span class="dv">3</span>, <span class="dt">target_group =</span> mysim$true_group)
group_order_k3</code></pre></div>
<pre><code>## [1] 3 1 2</code></pre>
<p>This tells us that group 3 in our simulated data matches the first group in the MCMC output, group 1 matches the second group in the MCMC output, and group 2 matches the third group in the MCMC output. Now that we know this, we can plot posterior allele frequencies in each subpopulation and overlay the correct corresponding values from the simulated data. Note that when ggplot objects are produced inside a loop we have to use the <code>print()</code> function to make them appear on the screen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># loop through subpopulations</span>
for (i in <span class="dv">1</span>:<span class="dv">3</span>) {
  
  <span class="co"># produce plot of posterior allele frequencies for this subpopulation</span>
  posterior_p &lt;-<span class="st"> </span><span class="kw"><a href="../reference/plot_p.html">plot_p</a></span>(myproj, <span class="dt">K =</span> <span class="dv">3</span>, <span class="dt">deme =</span> i)
  
  <span class="co"># get true simulated allele frequencies for this subpopulation</span>
  sim_p &lt;-<span class="st"> </span><span class="kw">mapply</span>(function(x){x[group_order_k3[i],<span class="dv">1</span>]}, mysim$true_p)
  
  <span class="co"># overlay true allele frequencies onto plot</span>
  posterior_p &lt;-<span class="st"> </span>posterior_p +<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/geom_point">geom_point</a></span>(<span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/aes">aes</a></span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">24</span>, <span class="dt">y =</span> sim_p), <span class="dt">col =</span> <span class="st">"red"</span>, <span class="dt">shape =</span> <span class="dv">4</span>)
  <span class="kw">print</span>(posterior_p)
}</code></pre></div>
<p><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-17-1.png" width="576"><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-17-2.png" width="576"><img src="tutorial-biallelic_files/figure-html/unnamed-chunk-17-3.png" width="576"></p>
<p>We can see that the MCMC has done a good job of estimating allele frequencies in all three subpopulations. This was made easier by the fact that allele frequencies are quite evenly distributed between 0 and 1, which is rarely the case in real data.</p>
<p>In the <a href="https://bobverity.github.io/MALECOT/articles/complex-priors.html">next tutorial</a> we will look at ways of adding realism to the model through more complex priors.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#simulate-some-data">Simulate some data</a></li>
      <li><a href="#create-a-project-and-read-in-data">Create a project and read in data</a></li>
      <li><a href="#define-parameters-and-run-basic-mcmc">Define parameters and run basic MCMC</a></li>
      <li><a href="#checking-mcmc-behaviour">Checking MCMC behaviour</a></li>
      <li><a href="#plot-results">Plot results</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Bob Verity.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
