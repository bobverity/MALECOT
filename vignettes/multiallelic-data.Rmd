---
title: "Multi-allelic data"
author: "Bob Verity"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{"Multi-allelic data"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE}
set.seed(3)
library(MALECOT)
```

This vignette demonstrates how MALECOT analysis differs for multi-allelic data, i.e. data for which there are more than two alleles at some loci. It covers:

1. how multi-allelic format differs from bi-allelic format
2. binding multi-allelic data to a project and running a basic MCMC
3. checking MCMC behaviour
4. plotting results
5. more realistic priors on multi-allelic allele frequencies

This tutorial assumes some prior knowledge about MALECOT - if you are new to the program we recommend working through the simpler [bi-allelic tutorial](https://bobverity.github.io/MALECOT/articles/tutorial-biallelic.html) first.

## Loading and running multi-allelic data

The data format that we used previously for the bi-allelic case cannot be used for multi-allelic data, because now we can observe more than just homozygous and heterozygous calls at a locus. Instead, if there are *J* alleles at a locus then we can observe any subset of these alleles, ranging from just a single allele to all *J* alleles. MALECOT accommodates this by reading in data in long format.

The easiest way to understand long format is to simulate some multi-allelic data. This can be done using the standard `sim_data()` function but with the argument `data_format = "multiallelic"`. As before, there are many elements that make up this simulated data including records of the true values used in simulation, but here we are only interested in the "data" element. Here we will draw data from 5 subpopulations covering a range of mean COIs from 1 to 5. We will assume that we have sequenced the samples at 10 loci, with each locus having 5 possible alleles. Finally, we will assume 10% missing data so we can see what this looks like:

```{r}
mysim <- sim_data(data_format = "multiallelic", n = 100, L = 10, K = 5, COI_mean = 1:5,
                  alleles = 5, prop_missing = 0.1)
```
```{r, echo=FALSE}
# secretly save/load data from file so results are consistent
#saveRDS(mysim, file = "../inst/extdata/tutorial3_mysim.rds")
mysim <- readRDS("../inst/extdata/tutorial3_mysim.rds")
```
```{r}
head(mysim$data)
```

We can see that long format data has three columns consisting of the sample ID, the locus, and the observed haplotype (the column names must match those shown above). The locus column must contain positive integer values starting at 1, meaning if loci are encoded as character strings then they must be converted to integers first. The same is true for haplotypes, which must be encoded as positive integers starting at 1, or as missing data.

Every locus must be represented in every sample, although but can be inserted using missing data. In the example above there was sequencing failure in sample001 at loci 2 and 3, but this sample still has entries for all 10 loci, we just use missing data instead of observed haplotypes.

Next we need to create a new project and bind the data, this time using the `bind_data_multiallelic()` function. When binding the data we have the option of specifying the number of alleles at each locus, or if this option is unspecified then the program uses the maximum observed value at that locus. For example, imagine that we sequence 10 samples at a highly diverse locus which we know from previous work to have 8 possible alleles. With such a small sample it is quite possible that we will only observe the first 5 alleles by chance. If we bind the data without the `alleles` argument then the model will assume 5 alleles at this locus, whereas if we use the `alleles` argument we can tell the model that there are 8 alleles and some were simply missed. This option is perhaps not so important when using real data, as we rarely know the number of alleles *a priori*, but it becomes very important when testing the power of the program on simulated data.

```{r}
myproj <- malecot_project()
myproj <- bind_data_multiallelic(myproj, df = mysim$data, alleles = 5)
```

Create parameter set

```{r}
myproj <- new_set(myproj, name = "tutorial multiallelic", COI_model = "nb", COI_max = 20,
                  estimate_COI_mean = TRUE, COI_dispersion = 2, lambda = 1,
                  estimate_error = TRUE, e1_max = 0.2, e2_max = 0.2)
```

Run mcmc

```{r}
myproj <- run_mcmc(myproj, K = 5, burnin = 1e4, converge_test = 1e2,
                   samples = 1e4, pb_markdown =  TRUE)
```

Check behaviour

```{r, fig.height=5, fig.width=8}
plot_loglike_dignostic(myproj, K = NULL)
get_ESS(myproj, K = NULL)
```

This is one the edge of OK.


## Plotting results

```{r, fig.height=2, fig.width=8}
# structure plot
plot_structure(myproj, K = NULL, divide_ind_on = TRUE)
```

```{r, fig.height=4, fig.width=8}
# load ggplot2 package
library(ggplot2)

# produce plot of posterior COIs
posterior_COI <- plot_COI(myproj, K = NULL)

# overlay true COI values
posterior_COI <- posterior_COI + geom_point(aes(x = 1:100, y = mysim$true_m), col = "red", shape = 4)
posterior_COI
```

Posterior allele frequencies

```{r, fig.height=4, fig.width=8}
# get group order
group_order_k3 <- get_group_order(myproj, K = 5, target_group = mysim$true_group)

# produce plot of posterior allele frequencies for this subpopulation
posterior_p <- plot_p(myproj, K = NULL, deme = 1)

# get true simulated allele frequencies for this subpopulation
sim_p <- mapply(function(x){x[group_order_k3[1], ]}, mysim$true_p, SIMPLIFY = FALSE)

# get plotting results into dataframe
df <- data.frame(locus = rep(1:10, each = 5),
                 p = unlist(sim_p),
                 allele = rep(1:5, 10))

# overlay true allele frequencies onto plot
posterior_p <- posterior_p + geom_point(aes(x = locus, y = p, group = allele), data = df,
                                        position = position_dodge(width = 0.9), col = "red", shape = 4)

posterior_p
```

## More realistic prior on allele frequencies


```{r, fig.height=4, fig.width=8}
plot_prior_p(lambda = c(1,5,2,3,4))
plot_prior_p(lambda = c(1,5,2,3,4)*10)
```
