---
title: "Basic tutorial"
author: "Bob Verity"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette demonstrates the complete MALECOT analysis pipeline, including:

* importing data
* running the main MCMC
* diagnosing good and bad MCMC behaviour
* comparing different models
* producing basic outputs.

```{r, echo=FALSE}
set.seed(1)
library(MALECOT)
```

### Simulate some data

MALECOT comes with built-in functions for simulating data from different models. The models used in simulation are exactly the same as the models used in the inference step, allowing us to test the power of the program without worrying about discrepancies between the data and the assumed model. We will simulate a data set of 100 samples, each genotyped at 20 bi-allelic loci and originating from 3 distinct subpopulations. We will assume that the mean complexity of infection (COI) in these subpopulation varies from 1 to 3:

```{r}
mysim <- sim_data(n = 100, data_format = "biallelic", L = 24, K = 3, COI_mean = c(3,2,1))
```

Running `names(mysim)` we can see that the simulated data contains several elements:

```{r}
names(mysim)
```

The raw data is stored in the "data" element. In addition, we have a record of the allele frequencies (p), the complexity of infection (m) and the grouping that were used in generating these data. These additional records can be useful in ground-truthing our estimated values later on, but are not actually used by the program - all that is needed for MALECOT analysis is the "data" element.

Data must be in dataframe format - when using real data, functions such as `read.csv()` and `read.table()` can be used to import data. Running `head(mysim$data)` we can see the general data format required by MALECOT:

```{r}
head(mysim$data)
```

Note that this is the required format **for bi-allelic data only** - for multi-allelic data see [this vignette](todo).

Samples are in rows and loci are in columns. There are also several meta-data columns, including the sample ID and the population of origin. These meta-data columns are optional and can be turned on or off when loading the data into a project.

The actual genetic data must be one of the following values

* 1 = homozygote for the reference allele
* 0 = homozygote for the alternative allele
* 0.5 = heterozygote
* -9 = missing data (the value used can be specified, but -9 is the default)

Note that MALECOT currently does not use within-sample allele frequency information other than in terms of the major homozygote/heterozygote call, therefore intermediate values should be converted to one of the above options. MALECOT does, however, include error terms to allow for misclassification of homozygote/heterozygote calls.

### Create a project and read in data

MALCOT works with projects, which are essentially just simple lists containing all the inputs and outputs of a given analysis. We start by creating a project and loading in our data:

```{r}
myproj <- malecot_project()
myproj <- bind_data_biallelic(myproj, mysim$data, ID_col = 1, pop_col = 2)
```

Notice the general format of the `bind_data()` function, which takes the same project as both input and output. This is the format that most MALECOT functions will take, as it allows a function to modify the project before overwriting the original version. In the input arguments we have also specified which columns are meta-data, and all other columns are assumed to contain genetic data.

We can view the project to check that the data have been loaded in correctly:

```{r}
myproj
```

If there have been mistakes in reading in the data, for example if meta-data columns have not been specified and so have been interpreted as genetic data (a common mistake) then this should be visible at this stage.

### Define parameters and run basic MCMC

We can define different models by using different parameter sets. Our first parameter set will represent a simple model in which any COI between 1 and `COI_max` is equally likely *a priori*, and in which there is zero error in genotype calls:

```{r}
myproj <- new_set(myproj, name = "uniform model", COI_model = "uniform",
                  COI_max = 20, estimate_error = FALSE, e1 = 0, e2 = 0)
```

Producing a summary of the project we can now see additional properties, including the current active set and the parameters of this set.

```{r}
myproj
```

Now we are ready to run a basic MCMC. We will start by exploring values of K from 1 to 5, using 1000 burn-in iterations and 1000 sampling iterations. By default the MCMC has `auto_converge` turned on, meaning it will test for convergence every `convergence_test` iterations and will exit if convergence is reached (`convergence_test = burnin/10` by default). Hence, it is generally a good idea to set `burnin` to be higher than expected, as the MCMC will adjust this number down if needed. The number of sampling iterations can also be tuned. Our aim when choosing the number of sampling iterations should be to obtain enough samples that our posterior estimates are accurate to an acceptable tolerance level, but not so many that we waste time running the MCMC for long periods past this point. We will look into this parameter again once the MCMC has completed. The most unfamiliar parameter for most users will be the number of "rungs". MALECOT runs multiple MCMC chains simultaneously, each at a different rung on a "temperature ladder". The cold chain is our ordinary MCMC chain, and the hot chains serve two purposes: 1) they improve MCMC mixing, 2) they are central to the GTI method of estimating the evidence for different models. Finally, for the sake of this document we will run with `pb_markdown = TRUE` to avoid printing large amounts of output, but you should run without this argument.

```{r}
myproj <- run_mcmc(myproj, K = 1:5, burnin = 1e4, converge_test = 1e2, samples = 1e3,
                   rungs = 10, pb_markdown =  TRUE)
```

If any values of K failed to converge then we can use the same `run_mcmc()` function to re-run the MCMC for just a single value of K and with different parameters (for example a longer burn-in). This will overwrite the existing output for the specified value of K, but will leave all other values untouched:

### Comparing values of K

The GTI method estimates the evidence for a given model by combining information across multiple temperature rungs. These rungs provide a series of point estimates that together make a "path", and the final evidence estimate is computed from the area between this path and the zero-line. We can visualise this path using the `plot_GTI_path()` function:

```{r}
plot_GTI_path(myproj, K = 3)
```

All plots produced by MALECOT are produced using [ggplot](https://ggplot2.tidyverse.org/), meaning they can be stored and modified later on - for example adding titles, legends etc.

In order for our evidence estimate to be unbiased it is important that the GTI path is relatively smooth. We can modify the smoothness of the path in two ways: 1) by increasing the number of `rungs` used in the MCMC, 2) by changing the value of `GTI_pow` which controls the curvature of the path (higher values lead to more steep curvature). Ideally we want a straight path, i.e. we want as little curvature as possible. In the example above we have a good number of rungs and a nice straight path, so there is no need to re-run the MCMC. **This check should be performed on every value of K**.

